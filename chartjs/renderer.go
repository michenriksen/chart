package chartjs

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"text/template"

	"github.com/michenriksen/chart"
)

const configTmpl = `// Chart.js configuration (https://www.chartjs.org/docs/latest/configuration/).
// Generated by chart (https://github.com/michenriksen/chart).
const config = {
  type: "bar",
  data: {
    datasets: [{
      data: {{ js .Values}},
    }],
    labels: {{.Labels}},
  },
  {{- with .Title }}
  options: {
    plugins: {
      title: {
        display: true,
        text: "{{ js . }}"
      }
    }
  }
  {{- end }}
}
`

// Renderer renders a [chart.Chart] as a basic configuration object for a
// Chart.js bar chart.
//
// See: https://www.chartjs.org/docs/latest/charts/bar.html
type Renderer struct {
	tmpl  *template.Template
	title string
}

// NewRenderer returns a [chart.Renderer] for rendering a [chart.Chart] as a
// basic configuration object for a Chart.js bar chart.
//
// See: https://www.chartjs.org/docs/latest/charts/bar.html
func NewRenderer(opts ...RendererOption) (*Renderer, error) {
	r := &Renderer{
		tmpl: template.Must(template.New("config").Parse(configTmpl)),
	}

	for i, opt := range opts {
		if err := opt(r); err != nil {
			return nil, fmt.Errorf("applying option #%d: %w", i+1, err)
		}
	}

	return r, nil
}

// Render renders chart to out writer.
func (r *Renderer) Render(c *chart.Chart, out io.Writer) (int, error) {
	labels := c.Labels()
	values := make([]float64, 0, len(labels))

	for _, label := range labels {
		value, err := c.Value(label)
		if err != nil {
			return 0, fmt.Errorf("getting value for %q label: %w", label, err)
		}

		values = append(values, value)
	}

	jsonLabels, err := json.Marshal(labels)
	if err != nil {
		return 0, fmt.Errorf("encoding labels: %w", err)
	}

	jsonValues, err := json.Marshal(values)
	if err != nil {
		return 0, fmt.Errorf("encoding values: %w", err)
	}

	buf := new(bytes.Buffer)
	data := map[string]any{
		"Labels": string(jsonLabels),
		"Values": string(jsonValues),
		"Title":  r.title,
	}

	if err := r.tmpl.Execute(buf, data); err != nil {
		return 0, fmt.Errorf("rendering configuration: %w", err)
	}

	n, err := out.Write(buf.Bytes())
	if err != nil {
		return n, fmt.Errorf("writing to out: %w", err)
	}

	return n, nil
}

// RendererOption configures a [Renderer].
type RendererOption func(*Renderer) error

// WithTitle configures a [Renderer] with a chart title.
func WithTitle(title string) RendererOption {
	return func(r *Renderer) error {
		r.title = title
		return nil
	}
}
